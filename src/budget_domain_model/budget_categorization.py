# ---------------------------------------------------------------------------- +
#region p3_budget_categorization.py module
""" Financial Budget Workflow: "categorization" of transaction workbooks.

    Workflow: categorization
    Input Folder: Financial Institution (FI) Incoming Folder (IF)
    Output Folder: Financial Institution (FI) Categorized Folder (CF)
    FI transaction workbooks are typically excel files. 

    Workflow Pattern: Apply a workflow_process (function) to each item in the 
    input folder, placing items in the output folder as appropriate to the 
    configured function. Each WorkFLow instance in the config applies one 
    function to the input with resulting output.

    TODO: Consider xlwings package for Excel integration.
"""
#endregion p3_execl_budget.p3_banking_transactions budget_transactions.py module
# ---------------------------------------------------------------------------- +
#region Imports
# python standard library modules and packages
import re, pathlib as Path, logging, time, hashlib, datetime
from dataclasses import dataclass

# third-party modules and packages
import p3logging as p3l, p3_utils as p3u
from openpyxl import Workbook, load_workbook
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.cell.cell import Cell

# local modules and packages
from budman_namespace import *
from budget_domain_model import (BudgetDomainModel, map_category, category_map_count)
# from data.p3_fi_transactions.budget_model import BudgetModel
#endregion Imports
# ---------------------------------------------------------------------------- +
#region Globals and Constants
logger = logging.getLogger(__name__)

# BOA workbook column name to column index mapping.
DATE_COL_NAME = "Date"  # Column name for transaction date.
DATE_COL_INDEX = 1      # Column index for transaction date.
DESCRIPTION_COL_NAME = "Original Description"  # Column name for transaction description.
DESCRIPTION_COL_INDEX = 2  # Column index for transaction description.
CURRENCY_COL_NAME = "Currency"
CURRENCY_COL_INDEX = 4  # Column name for transaction amount.
AMOUNT_COL_NAME = "Amount"  # Column name for transaction amount.
AMOUNT_COL_INDEX = 6  # Column index for transaction amount.
ACCOUNT_NAME_COL_NAME = "Account Name"  # Column name for account name.
ACCOUNT_NAME_COL_INDEX = 10  # Column index for account name.
BUDGET_CATEGORY_COL = "Budget Category"  # Column name for budget category.
BUDGET_CATEGORY_COL_INDEX = 12  # Column index for budget category.


#endregion Globals and Constants
#region dataclasses
@dataclass
class TransactionData:
    """Data class to hold transaction data."""
    tid: str = None   # Transaction ID.
    date: datetime.date = None  # Transaction date - ISO 8601 format.
    description: str = None  # Transaction description.
    currency: str = None  # Transaction currency.
    amount: float = 0.0  # Transaction amount.
    category: str = None  # Transaction budget category.

    def data_str(self) -> str:
        """Return a string representation of the transaction data."""
        ret =  f"{self.tid:12}|{self.date.strftime("%m/%d/%Y")}|"
        ret += f"{self.amount:>+12.2f}|" 
        ret += f"({len(self.description):03}){self.description:102}|->" 
        ret += f"|({len(self.category):03})|{self.category:40}|"
        return ret
    
#endregion dataclasses
# ---------------------------------------------------------------------------- +
#region generate_hash_key(text:str) -> str
def generate_hash_key(text: str, length:int=12) -> str:
    """Generate a hash key for the given text.
    
    The hash key is generated by removing all non-alphanumeric characters 
    from the text, converting it to lowercase, and then hashing it using 
    SHA-256. The resulting hash is then converted to a hexadecimal string.

    Args:
        text (str): The input text to generate a hash key for.

    Returns:
        str: The generated hash key.
    """
    try:
        if not isinstance(text, str):
            raise TypeError(f"Expected 'text' arg to be a str, got {type(text)}")
        # Remove non-alphanumeric characters and convert to lowercase.
        # cleaned_text = re.sub(r'\W+', '', text).lower()
        # Generate the SHA-256 hash of the cleaned text.
        hash_object = hashlib.sha256(text.encode())
        # Convert the hash to a hexadecimal string.
        return hash_object.hexdigest()[:length]  #.[:HASH_KEY_LENGTH]
    except Exception as e:
        logger.error(p3u.exc_err_msg(e))
        raise
#endregion generate_hash_key(text:str) -> str
# ---------------------------------------------------------------------------- +
#region check_budget_category() function
def check_budget_category(sheet:Worksheet) -> bool:
    """Check that the sheet is ready to process budget category.
    
    A column 'Budget Category' is added to the sheet if it does not exist.

    Args:
        sheet (openpyxl.worksheet): The worksheet to map.
    """
    try:
        logger.info("Check worksheet for budget category.")
        # Is BUDGET_CATEGORY_COL in the sheet?
        col_names = [cell.value for cell in sheet[1]]
        if BUDGET_CATEGORY_COL in col_names:
            logger.info(f"Column '{BUDGET_CATEGORY_COL}' already exists in sheet.")
            return True 
        # Add the column to the sheet.
        i = sheet.max_column + 1
        sheet.insert_cols(i)
        sheet.cell(row=1, column=i).value = BUDGET_CATEGORY_COL
        # Set the column width to 20.
        sheet.column_dimensions[sheet.cell(row=1, column=i).column_letter].width = 20
        logger.info(f"Adding column '{BUDGET_CATEGORY_COL}' at index = {i}, "
                    f"column_letter = '{sheet.cell(row=1, column=i).column_letter}'")
        logger.info(f"Completed checks for budget category.")
        return True
    except Exception as e:
        logger.error(p3u.exc_err_msg(e))
        raise    
#endregion check_budget_category() function
# ---------------------------------------------------------------------------- +
#region WORKSHEET_data(ws:Worksheet) -> List[TransactionData]
def WORKSHEET_data(ws:Worksheet, just_values:bool=False) -> list[TransactionData]:
    """Extract transaction data from a worksheet.

    Args:
        ws (Worksheet): The worksheet to extract data from.

    Returns:
        list[TransactionData]: A list of TransactionData objects.
    """
    try:
        if not isinstance(ws, Worksheet):
            raise TypeError(f"Expected 'ws' arg to be a Worksheet, got {type(ws)}")
        transactions = []
        for row in ws.iter_rows(min_row=2, values_only=just_values):
            transaction = WORKSHEET_row_data(row)  # Extract transaction data from the row.
            transactions.append(transaction)
        return transactions
    except Exception as e:
        logger.error(p3u.exc_err_msg(e))
        raise
#endregion WORKSHEET_data(ws:Worksheet) -> List[TransactionData]
# ---------------------------------------------------------------------------- +
#region WORKSHEET_row_data(row:list) -> TransactionData
def WORKSHEET_row_data(row:tuple) -> TransactionData:
    """Extract transaction data from a worksheet row.

    Args:
        row (list): Array of cell values.

    Returns:
        list[TransactionData]: A list of TransactionData objects.
    """
    try:
        if not isinstance(row, tuple):
            raise TypeError(f"Expected 'row' arg to be a tuple, got {type(row)}")
        if isinstance(row[0], Cell):
            t_date_str = p3u.iso_date_only_string(row[DATE_COL_INDEX].value)  # Date is in the second column.
            t_desc = row[DESCRIPTION_COL_INDEX].value  # Description is in the third column.
            t_currency = row[CURRENCY_COL_INDEX].value  # Currency is in the fifth column.
            t_amt_str = str(row[AMOUNT_COL_INDEX].value) 
        else:
            t_date_str = p3u.iso_date_only_string(row[DATE_COL_INDEX])  # Date is in the second column.
            t_desc = row[DESCRIPTION_COL_INDEX]  # Description is in the third column.
            t_currency = row[CURRENCY_COL_INDEX]  # Currency is in the fifth column.
            t_amt_str = str(row[AMOUNT_COL_INDEX]) 
        t_all_str = t_date_str + t_desc + t_currency + t_amt_str
        t_id = generate_hash_key(t_all_str)  # Generate a unique ID for the transaction.
        if isinstance(row[0], Cell):
            transaction = TransactionData(
                tid=t_id,
                date=row[DATE_COL_INDEX].value,
                description=row[DESCRIPTION_COL_INDEX].value,
                currency=row[CURRENCY_COL_INDEX].value,
                amount=row[AMOUNT_COL_INDEX].value,
                category=row[BUDGET_CATEGORY_COL_INDEX].value  # Category will be set later.
            )
        else:
            transaction = TransactionData(
                tid=t_id,
                date=p3u.iso_date_only_string(row[DATE_COL_INDEX]),
                description=row[DESCRIPTION_COL_INDEX],
                currency=row[CURRENCY_COL_INDEX],
                amount=float(row[AMOUNT_COL_INDEX]),
                category=row[BUDGET_CATEGORY_COL_INDEX]  # Category will be set later.
            )
        return transaction
    except Exception as e:
        logger.error(p3u.exc_err_msg(e))
        raise
#endregion WORKSHEET_row_data(row:list) -> TransactionData
# ---------------------------------------------------------------------------- +
#region map_budget_category() function
def map_budget_category(sheet:Worksheet,src,dst) -> None:
    """Map a src column to budget category putting result in dst column.
    
    The sheet has banking transaction data in rows and columns. 
    Column 'src' has the text presumed to be about the transaction.
    Column 'dst' will be assigned a mapped budget category. Append
    column 'Budget Category' if it is not already in the sheet.
    TODO: pass in a mapper function to map the src text to a budget category.

    Args:
        sheet (openpyxl.worksheet): The worksheet to map.
        src (str): The source column to map from.
        dst (str): The destination column to map to. 
    """
    try:
        _ = p3u.is_str_or_none("src", src, raise_TypeError=True)
        _ = p3u.is_str_or_none("dst", dst, raise_TypeError=True)
        rules_count = category_map_count()
        logger.info(f"Applying '{rules_count}' budget category mappings "
                    f"to {sheet.max_row-1} rows in sheet: '{sheet.title}' ")
        # transactions = WORKSHEET_data(sheet)
        header_row = [cell.value for cell in sheet[1]] 
        if src in header_row:
            src_col_index = header_row.index(src) + 1
        else:
            logger.error(f"Source column '{src}' not found in header row.")
            return
        if dst in header_row:
            dst_col_index = header_row.index(dst) + 1
        else:
            logger.error(f"Destination column '{dst}' not found in header row.")
            return

        logger.info(f"Mapping '{src}'({src_col_index}) to "
                    f"'{dst}'({dst_col_index})")
        num_rows = sheet.max_row # or set a smaller limit
        other_count = 0
        for row in sheet.iter_rows(min_row=2):
            # row is a type 'tuple' of Cell objects.
            row_idx = row[0].row  # Get the row index.
            src_cell = row[DESCRIPTION_COL_INDEX]
            dst_cell = row[BUDGET_CATEGORY_COL_INDEX]
            src_value = row[DESCRIPTION_COL_INDEX].value 
            dst_value = map_category(src_value)  
            row[BUDGET_CATEGORY_COL_INDEX].value = dst_value 
            dst_cell.value = dst_value 
            transaction = WORKSHEET_row_data(row) 
            trans_str = transaction.data_str()
            del transaction  # Clean up the transaction object.
            if dst_value == 'Other':
                other_count += 1
                logger.debug(f"{row_idx:04}:{trans_str}" )
        logger.info(f"Completed budget category mapping for '{num_rows}' rows. "
                    f"Other count: '{other_count}'.")
        return None
    except Exception as e:
        logger.error(p3u.exc_err_msg(e))
        raise    
#endregion map_budget_category() function
# ---------------------------------------------------------------------------- +
#region def execute_worklow_categorization(bm : BudgetModel, fi_key: str) -> None:
def execute_worklow_categorization(bm : BudgetDomainModel, fi_key: str, wf_key:str) -> None:
    """Process categorization wf_key for Financial Institution's 
    transaction workbooks.

    Execute the categorization wf_key to examine all fi transaction 
    workbooks presently in the IF (Incoming Folder) for the indicated 
    FI (Financial Institution). Each workbook file is opened and the 
    transactions are categorized and saved to the CF (Categorized Folder) 
    for the indicated FI.

    Args:
        bm (BudgetModel): The BudgetModel instance to use for processing.
        fi_key (str): The key for the financial institution.
    """
    # TODO: add logs directory to the budget folder.
    st = p3u.start_timer()
    wb_name = "BOAChecking2025.xlsx"
    cp = "Budget Model Categorization:"
    loaded_workbooks = {}
    # Execute a workflow for a specific financial institution (fi_key).
    #   The pattern is to apply a function based on wf_key to each item in 
    #   the input folder based on fi_key and wf_key.
    #   Execute steps:
    #     1: Load the input items from storage.
    #     2: Apply the workflow function to each input item.
    #     3: Save the output items to storage. 
    try:
        logger.info(f"{cp} Start: workflow: '{wf_key}' for FI('{fi_key}') ...")
        wb_type = WF_INPUT # input workbooks
        wb_c = bm.bdm_FI_WF_WORKBOOK_LIST_count(fi_key, wf_key, wb_type)
        # workbooks_dict = bm.bsm_WF_INPUT(fi_key, BDM_WF_INTAKE)
        # if workbooks_dict is None or len(workbooks_dict) == 0:
        if wb_c is None or wb_c == 0:
            logger.info(f"{cp}    No workbooks for input.")
            return
        logger.info(f"{cp}    {wb_c} workbooks for input.")
        # Now process each input workbook.
        # for wb_name, wb_ap in reversed(workbooks_dict.items()):
        # Step 1: Load the workbooks sequentially.
        for wb_name, wb in bm.bsm_FI_WF_WORKBOOKS_generate(fi_key, wf_key, wb_type):
            logger.info(f"{cp}    Workbook({wb_name})")
                
            # Step 2: Process the workbooks applying the workflow function
            try: 
                logger.info(f"{cp}    Workbook({wb_name})")
                sheet = wb.active
                # Check for budget category column, add it if not present.
                check_budget_category(sheet)
                # Map the 'Original Description' column to the 'Budget Category' column.
                map_budget_category(sheet, "Original Description", BUDGET_CATEGORY_COL)
            except Exception as e:
                logger.error(f"{cp}    Error processing workbook: {wb_name}: {e}")
                continue

            # Step 3: Save the output items to output storage.
            try:
                bm.bsm_FI_WF_WORKBOOK_save(wb, wb_name, fi_key, wf_key, WF_OUTPUT)
            except Exception as e:
                logger.error(f"{cp}    Error saving workbook: {wb_name}: {e}")
                continue
        logger.info(f"{cp} Complete: wf_key: '{wf_key}' {p3u.stop_timer(st)}")
    except Exception as e:
        m = p3u.exc_err_msg(e)
        logger.error(m)
        raise
#endregion execute_worklow_categorization() function
# ---------------------------------------------------------------------------- +